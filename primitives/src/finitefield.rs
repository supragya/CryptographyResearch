//! This module containt the definition of the trait `FiniteField`

use std::{
    fmt::Debug, hash::Hash, iter::{Product, Sum}, ops::{
        Add, AddAssign, Div, DivAssign, Mul, MulAssign, Neg, Rem, Sub, SubAssign
    }
};

/// A field is a set of elements on which the following operations are defined:
/// - Addition
/// - Subtraction
/// - Multiplication
/// - Division
///
/// A "finite field" is a field with "finite" number of elements

pub trait FiniteField:
    Debug
    + From<usize> // assumed that all fields in use will be build-able from
                  // `usize`
    + Default
    + Sized
    + Copy
    + Clone
    // One should be able to compare two elements for equality
    + PartialEq
    + Eq 
    // Addition operations
    + AddAssign
    + Add<Output = Self>
    + Sum
    // Subtraction operations
    + SubAssign
    + Sub<Output = Self>
    // Multiplication operations
    + MulAssign
    + Mul<Output = Self>
    + Product
    // Division operationss
    + DivAssign
    + Div<Output = Self>
    + Rem<Output = Self> // if you can divide, you can rem
    // Unary operations
    + Neg<Output = Self> // required for additive identity
    // Hashability is required
    + Hash
    + 'static

    {
    /// The order of the field is the number of elements in the field
    const ORDER: usize;

    /// The additive identity element
    const ZERO: Self;

    /// The multiplicative identity element
    const ONE: Self;

    /// Multiplicative generator of the group
    /// also called the primitive element
    const MULTIPLICATIVE_GENERATOR: Self;

    // REQUIRED IMPLEMENTATIONS
    
    /// Gets the multiplicative inverse of a field element if it exists.
    fn multiplicative_inverse(&self) -> Option<Self>;

    /// Computes the power of a field element
    fn pow(self, pow: usize) -> Self;

    /// Returns the primitive n-th root of unity in the field.
    /// All fields of prime order have
    /// - An Additive group
    /// - A multiplicative subgroup generated by generator `g`
    ///
    /// According to Sylow's theorem, for existence of a non-trivial
    /// multiplicative subgroup of prime order `n`, `p-1` should be divisible
    /// by `n`. (-1) because `0` cannot be part of the multiplicative
    /// subgroup.
    fn primitive_root_of_unity(n: usize) -> Self {
        // Check for divisibility of (p-1)
        let remainder = (Self::ORDER - 1) % n;
        assert!(remainder == 0, "n must divide (field_order - 1)");

        // Multiply the generator by how small the subgroup is
        // with respect to (p-1)
        Self::MULTIPLICATIVE_GENERATOR.pow((Self::ORDER - 1) / n)
    }
    
}
